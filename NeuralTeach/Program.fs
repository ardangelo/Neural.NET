// Learn more about F# at http://fsharp.net
// See the 'F# Tutorial' project for more help.

open MathNet.Numerics.LinearAlgebra
open System.IO
open NeuralNet

[<EntryPoint>]
let main argv = 
    let sizes = [784;30;10]

    let resultVectors = [
        DenseVector.ofList [1.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0; 0.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 1.0; 0.0];
        DenseVector.ofList [0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 0.0; 1.0]];
    let learnfiles = [
        "../../../teach-data/0-learn";
        "../../../teach-data/1-learn";
        "../../../teach-data/2-learn";
        "../../../teach-data/3-learn";
        "../../../teach-data/4-learn";
        "../../../teach-data/5-learn";
        "../../../teach-data/6-learn";
        "../../../teach-data/7-learn";
        "../../../teach-data/8-learn";
        "../../../teach-data/9-learn"]

    let testfiles = [
        "../../../teach-data/0-test";
        "../../../teach-data/1-test";
        "../../../teach-data/2-test";
        "../../../teach-data/3-test";
        "../../../teach-data/4-test";
        "../../../teach-data/5-test";
        "../../../teach-data/6-test";
        "../../../teach-data/7-test";
        "../../../teach-data/8-test";
        "../../../teach-data/9-test"]
    
    let bw = new BinaryWriter(File.Open("log.txt", FileMode.Create))
    bw.Write("open log")

    let rec buildExamples(rs : Vector<double> list, fs : string list) = 
        if rs.Length = 0 then List.empty else
        let reader = new BinaryReader(File.Open(fs.Head, FileMode.Open))

        let toDouble(b1 : int, b2 : int) : double =
            let hex : string = new string([(char)(b1);(char)(b2)] |> Array.ofList)
            (double)(System.Int32.Parse(hex, System.Globalization.NumberStyles.AllowHexSpecifier))

        let readNextMNIST(br : BinaryReader) =
            DenseVector.ofList [for i in 1 .. 784 do yield toDouble(reader.Read(),reader.Read()) / (double)0xff]
        let images = (int)(reader.BaseStream.Length) / (784 * 2)
        let digits = [for i in 1 .. images do yield (readNextMNIST(reader), rs.Head)]

        List.append digits (buildExamples (rs.Tail, fs.Tail))

    let examples = buildExamples(resultVectors, learnfiles)
    let testdata = buildExamples(resultVectors, testfiles)

    let network = Network.Randomize(sizes)
    let (w, b) = network.Teach(examples, 3.0, 10, 30, testdata)

    ignore [for wl in w do bw.Write(wl.ToString())]
    ignore [for bl in b do bw.Write(bl.ToString())]

    let zero : double list = Array.toList [|0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.200; 0.624; 0.992; 0.624; 0.196; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.188; 0.933; 0.988; 0.988; 0.988; 0.929; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.212; 0.890; 0.992; 0.988; 0.937; 0.914; 0.988; 0.224; 0.024; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.039; 0.235; 0.878; 0.988; 0.992; 0.988; 0.792; 0.329; 0.988; 0.992; 0.478; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.639; 0.988; 0.988; 0.988; 0.992; 0.988; 0.988; 0.376; 0.741; 0.992; 0.655; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.200; 0.933; 0.992; 0.992; 0.745; 0.447; 0.992; 0.894; 0.184; 0.310; 1.000; 0.659; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.188; 0.933; 0.988; 0.988; 0.702; 0.047; 0.294; 0.475; 0.082; 0.000; 0.000; 0.992; 0.953; 0.196; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.149; 0.647; 0.992; 0.914; 0.816; 0.329; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.992; 0.988; 0.647; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.027; 0.698; 0.988; 0.941; 0.278; 0.075; 0.110; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.992; 0.988; 0.765; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.224; 0.988; 0.988; 0.247; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.992; 0.988; 0.765; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.776; 0.992; 0.745; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 1.000; 0.992; 0.769; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.298; 0.965; 0.988; 0.439; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.992; 0.988; 0.580; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.333; 0.988; 0.902; 0.098; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.027; 0.529; 0.992; 0.729; 0.047; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.333; 0.988; 0.875; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.027; 0.514; 0.988; 0.882; 0.278; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.333; 0.988; 0.569; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.188; 0.647; 0.988; 0.678; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.337; 0.992; 0.882; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.447; 0.933; 0.992; 0.635; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.333; 0.988; 0.976; 0.573; 0.188; 0.114; 0.333; 0.698; 0.882; 0.992; 0.875; 0.655; 0.220; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.333; 0.988; 0.988; 0.988; 0.898; 0.843; 0.988; 0.988; 0.988; 0.769; 0.510; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.110; 0.780; 0.988; 0.988; 0.992; 0.988; 0.988; 0.914; 0.569; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.098; 0.502; 0.988; 0.992; 0.988; 0.553; 0.145; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000; 0.000|]

    let z = network.Output(zero)
    bw.Write(z.ToString())
    
    0 // return an integer exit code
